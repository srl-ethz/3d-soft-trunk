//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: J_fun.cpp
//
// MATLAB Coder version            : 5.1
// C/C++ source code generated on  : 27-Jul-2021 20:54:26
//

// Include Files
#include "J_fun.h"
#include <cmath>

// Function Definitions
//
// J_FUN
//     J = J_FUN(q,L)
// Arguments    : const double in1[4]
//                const double in2[2]
//                double J[12]
// Return Type  : void
//
void J_fun(const double in1[4], const double in2[2], double J[12])
{
  double J_tmp;
  double J_tmp_tmp;
  double b_J_tmp;
  double c_J_tmp;
  double d_J_tmp;
  double e_J_tmp;
  double f_J_tmp;
  double g_J_tmp;
  double h_J_tmp;
  double i_J_tmp;
  double j_J_tmp;
  double t11;
  double t12;
  double t13;
  double t15;
  double t16;
  double t17;
  double t18;
  double t2;
  double t27;
  double t28;
  double t29;
  double t3;
  double t30;
  double t30_tmp;
  double t4;
  double t5;
  double t6;
  double t7;
  double t8;
  double t9;

  //     This function was generated by the Symbolic Math Toolbox version 8.6.
  //     27-Jul-2021 20:38:44
  t2 = std::cos(in1[0]);
  t3 = std::cos(in1[1]);
  t4 = std::cos(in1[2]);
  t5 = std::cos(in1[3]);
  t6 = std::sin(in1[0]);
  t7 = std::sin(in1[1]);
  t8 = std::sin(in1[2]);
  t9 = std::sin(in1[3]);
  t15 = 1.0 / in1[1];
  t17 = 1.0 / in1[3];
  t11 = t2 * t2;
  t12 = std::sin(in1[0] * 2.0);
  t13 = t6 * t6;
  t16 = t15 * t15;
  t18 = t17 * t17;
  t27 = t11 * 2.0 - 1.0;
  t28 = t11 + t3 * t13;
  t29 = (t3 * t11 + -t11) + 1.0;
  t30_tmp = in2[1] * t7;
  t30 = t30_tmp * t17 * (t5 - 1.0) * std::sin(in1[0] + -in1[2]);
  J_tmp = in2[1] * t2;
  b_J_tmp = in2[1] * t8;
  J_tmp_tmp = in2[1] * t6 * t7;
  c_J_tmp = J_tmp_tmp * t9;
  d_J_tmp = J_tmp * t4;
  J[0] = ((-in2[0] * t6 * t15 * (t3 - 1.0) + c_J_tmp * t17) + b_J_tmp * t17 *
          (t3 - 1.0) * (t5 - 1.0) * t27) - d_J_tmp * t6 * t17 * (t3 - 1.0) * (t5
    - 1.0) * 2.0;
  e_J_tmp = -in2[0] * t2;
  f_J_tmp = in2[1] * t4;
  g_J_tmp = J_tmp * t6 * t8 * t17 * (t3 - 1.0) * (t5 - 1.0);
  h_J_tmp = J_tmp * t7 * t9;
  J[1] = ((e_J_tmp * t15 * (t3 - 1.0) + h_J_tmp * t17) - f_J_tmp * t17 * (t3 -
           1.0) * (t5 - 1.0) * t27) - g_J_tmp * 2.0;
  J[2] = t30;
  i_J_tmp = f_J_tmp * t7;
  j_J_tmp = t30_tmp * t8;
  J_tmp *= t3;
  J[3] = (((e_J_tmp * t7 * t15 - in2[0] * t2 * t16 * (t3 - 1.0)) - J_tmp * t9 *
           t17) - j_J_tmp * t12 * t17 * (t5 - 1.0) / 2.0) + i_J_tmp * t17 * (t5
    - 1.0) * -t11;
  e_J_tmp = in2[0] * t6;
  t27 = in2[1] * t3;
  t11 = t27 * t6;
  J[4] = (((e_J_tmp * t7 * t15 + e_J_tmp * t16 * (t3 - 1.0)) + t11 * t9 * t17) +
          i_J_tmp * t12 * t17 * (t5 - 1.0) / 2.0) + j_J_tmp * t13 * t17 * (t5 -
    1.0);
  J[5] = (((-in2[0] * t3 * t15 + in2[0] * t7 * t16) + t30_tmp * t9 * t17) -
          J_tmp * t4 * t17 * (t5 - 1.0)) - t11 * t8 * t17 * (t5 - 1.0);
  J_tmp = f_J_tmp * t12;
  J[6] = -in2[1] * t8 * t17 * (t5 - 1.0) * t29 + J_tmp * t17 * (t3 - 1.0) * (t5
    - 1.0) / 2.0;
  J[7] = -in2[1] * t4 * t17 * (t5 - 1.0) * t28 + g_J_tmp;
  J[8] = -t30;
  e_J_tmp = b_J_tmp * t9;
  g_J_tmp = f_J_tmp * t9;
  J[9] = ((((-in2[1] * t2 * t5 * t7 * t17 + h_J_tmp * t18) - g_J_tmp * t17 * t29)
           - f_J_tmp * t18 * (t5 - 1.0) * t29) - e_J_tmp * t12 * t17 * (t3 - 1.0)
          / 2.0) - b_J_tmp * t12 * t18 * (t3 - 1.0) * (t5 - 1.0) / 2.0;
  J[10] = ((((in2[1] * t5 * t6 * t7 * t17 - c_J_tmp * t18) + e_J_tmp * t17 * t28)
            + b_J_tmp * t18 * (t5 - 1.0) * t28) + g_J_tmp * t12 * t17 * (t3 -
            1.0) / 2.0) + J_tmp * t18 * (t3 - 1.0) * (t5 - 1.0) / 2.0;
  J_tmp = d_J_tmp * t7;
  b_J_tmp = J_tmp_tmp * t8;
  J[11] = ((((-in2[1] * t3 * t5 * t17 + t27 * t9 * t18) + J_tmp * t9 * t17) +
            b_J_tmp * t9 * t17) + J_tmp * t18 * (t5 - 1.0)) + b_J_tmp * t18 *
    (t5 - 1.0);
}

int main(){
  double J[16];
  double q[4] = {0.3, 0.4, 0.3, 0.5};
  double L[2] = {0.125, 0.125};
  J_fun(q,L,J);
  Eigen::MatrixXd Jacobian = Eigen::MatrixXd::Zero(4,4);
  for (int i = 0; i < 4; i++){
    for(int j = 0; j < 4; j++){
      Jacobian(i,j) = J[4*i+j];
    }
  }
  std::cout << Jacobian << std::endl;
}

//
// File trailer for J_fun.cpp
//
// [EOF]
//
