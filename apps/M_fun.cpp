//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: M_fun.cpp
//
// MATLAB Coder version            : 5.1
// C/C++ source code generated on  : 27-Jul-2021 11:30:52
//

// Include Files
#include "M_fun.h"
#include <cmath>
#include <iostream>
#include <Eigen/Dense>
// Function Definitions
//
// M_FUN
//     M = M_fun(q,L,m);
// Arguments    : const double in1[4]
//                const double in2[2]
//                const double in3[2]
//                double M[16]
// Return Type  : void
//
void M_fun(const double in1[4], const double in2[2], const double in3[2], double
           M[16])
{
  double a;
  double a_tmp;
  double a_tmp_tmp;
  double b_a_tmp;
  double b_a_tmp_tmp;
  double b_t127_tmp;
  double b_t130_tmp;
  double b_t138_tmp;
  double c_t127_tmp;
  double t10;
  double t11;
  double t116;
  double t116_tmp;
  double t116_tmp_tmp;
  double t127;
  double t127_tmp;
  double t13;
  double t130;
  double t130_tmp;
  double t132;
  double t134;
  double t134_tmp;
  double t138_tmp;
  double t140;
  double t15;
  double t16;
  double t17;
  double t18;
  double t19;
  double t2;
  double t22;
  double t23;
  double t24;
  double t25;
  double t27;
  double t27_tmp;
  double t3;
  double t32;
  double t33;
  double t4;
  double t42;
  double t44;
  double t45;
  double t45_tmp;
  double t47;
  double t5;
  double t50;
  double t51;
  double t52;
  double t54;
  double t59;
  double t6;
  double t60;
  double t66;
  double t7;
  double t70;
  double t8;
  double t84;
  double t84_tmp;
  double t9;
  double t95;

  //     This function was generated by the Symbolic Math Toolbox version 8.7.
  //     26-Jul-2021 21:32:18
  t2 = std::cos(in1[0]);
  t3 = std::cos(in1[1]);
  t4 = std::cos(in1[2]);
  t5 = std::cos(in1[3]);
  t6 = std::sin(in1[0]);
  t7 = std::sin(in1[1]);
  t8 = std::sin(in1[2]);
  t9 = std::sin(in1[3]);
  t10 = in2[1] * in1[1];
  t11 = in2[0] * 2.0;
  t13 = in2[1] * in2[1];
  t24 = 1.0 / (in1[3] * in1[3]);
  t27_tmp = in2[0] * in1[3];
  t27 = t27_tmp * -2.0;
  t15 = in1[3] * t11;
  t16 = t2 * t2;
  t17 = t4 * t4;
  t18 = t6 * t6;
  t19 = in1[1] * t7;
  t22 = 1.0 / (in1[1] * in1[1]);
  t25 = t7 * t10;
  t32 = t3 * t10;
  t33 = t5 * t10;
  t45_tmp = in1[1] * t9;
  t45 = t45_tmp * t10;
  t54 = t3 * t27;
  t60 = t27_tmp * t4 * t6 * 4.0;
  t23 = t22 * t22;
  t42 = std::sin(in1[0] + -in1[2]);
  t44 = t5 * (t3 * t11);
  t47 = t15 * t19;
  t50 = (t3 - 1.0) * (t3 - 1.0);
  t51 = (t5 - 1.0) * (t5 - 1.0);
  t52 = t5 * t32;
  t66 = t45_tmp * t32;
  t70 = t3 * t5 * -t10;
  a = t19 + (t3 - 1.0);
  t84_tmp = t2 * t6;
  t84 = t84_tmp * t10 * t19;
  t116_tmp_tmp = t4 * t8;
  t116_tmp = t116_tmp_tmp * t19;
  t116 = t116_tmp * t33;
  t59 = t3 * (t9 * t15);
  t95 = a * a;
  t127_tmp = in2[1] * in3[1];
  b_t127_tmp = t127_tmp * t22 * t24;
  c_t127_tmp = b_t127_tmp * (t5 - 1.0);
  t127 = c_t127_tmp * t42 * ((t15 + t45) + t54) / 4.0;
  a_tmp_tmp = t2 * t4;
  a_tmp = a_tmp_tmp * t19;
  b_a_tmp_tmp = t6 * t8;
  b_a_tmp = b_a_tmp_tmp * t19;
  a = ((((((t27 + t3 * t15) + t47) + t66) + a_tmp * -t10) + b_a_tmp * -t10) +
       a_tmp * t33) + b_a_tmp * t33;
  t132 = a * a;
  t134_tmp = t127_tmp * (1.0 / in1[1]) * t24;
  t134 = t134_tmp * (t5 - 1.0) * (((((((((-t10 + t32) + t33) + a_tmp_tmp * t15)
    + b_a_tmp_tmp * t15) + t70) + a_tmp_tmp * t9 * t25) + a_tmp_tmp * t54) +
    b_a_tmp_tmp * t9 * t25) + b_a_tmp_tmp * t54) / 4.0;
  t130_tmp = in2[0] * t3;
  b_t130_tmp = in2[0] * t5;
  t130 = t134_tmp * t42 * (((((((t11 + t130_tmp * -2.0) + b_t130_tmp * -2.0) +
    -t25) + t9 * t27) + t44) + t5 * t25) + t59) / 4.0;
  t140 = in1[1] * t2;
  t134_tmp = t140 * t4;
  t138_tmp = in1[1] * t6 * t8;
  b_t138_tmp = in2[0] * t2;
  t127_tmp = t27_tmp * t2;
  t11 = b_t127_tmp * (((((((((((((((((((-(t45_tmp * t11) - a_tmp_tmp * t11) -
    b_a_tmp_tmp * t11) - t5 * t7 * t15) + t134_tmp * t10) + t138_tmp * t10) -
    b_a_tmp_tmp * t44) - a_tmp_tmp * t44) - a_tmp_tmp * t59) - b_a_tmp_tmp * t59)
    + t5 * (t134_tmp * -t10)) + t5 * (t138_tmp * -t10)) + in2[0] * t7 * t9 * 2.0)
    + in2[0] * in1[1] * in1[3] * t5 * 2.0) + b_t138_tmp * t3 * t4 * 2.0) +
    b_t138_tmp * t4 * t5 * 2.0) + t130_tmp * t6 * t8 * 2.0) + b_t130_tmp * t6 *
                        t8 * 2.0) + t127_tmp * t4 * t9 * 2.0) + t27_tmp * t6 *
                      t8 * t9 * 2.0) / 4.0;
  a_tmp = t2 * t8;
  b_a_tmp = t4 * t6;
  t140 = c_t127_tmp * (((((((((((((((((t127_tmp * t8 * 4.0 + -t60) + t3 * t60) +
    t84) + a_tmp * t45) + b_a_tmp * t47) + t127_tmp * t3 * t8 * -4.0) + a_tmp *
    t19 * t27) + in1[1] * t4 * t6 * t9 * -t10) + t116_tmp * -t10) + b_a_tmp *
    t66) + t116) + t2 * t5 * t6 * t19 * -t10) + t140 * t3 * t8 * t9 * -t10) +
    t16 * (t116_tmp_tmp * t10 * t19) * 2.0) + -(t17 * t84 * 2.0)) + t17 *
                        (t84_tmp * t19 * t33) * 2.0) + -(t16 * t116 * 2.0)) /
    4.0;
  a_tmp = t4 * t10;
  b_a_tmp = t4 * t16;
  b_t130_tmp = t84_tmp * t8;
  a = (((((((((((((a_tmp + t2 * t15) + t2 * t54) + t4 * t52) - a_tmp * t16 * 2.0)
               + t3 * t4 * -t10) + t4 * t5 * -t10) + t2 * t9 * t25) + b_a_tmp *
            t32 * 2.0) + b_a_tmp * t33 * 2.0) - b_a_tmp * t52 * 2.0) -
         b_t130_tmp * t10 * 2.0) + b_t130_tmp * t32 * 2.0) + b_t130_tmp * t33 *
       2.0) - b_t130_tmp * t52 * 2.0;
  a_tmp = t8 * t16;
  b_a_tmp = a_tmp_tmp * t6;
  t130_tmp = (((((((((((((t6 * t15 + t8 * -t10) + t8 * t32) + t8 * t33) + t6 *
                       t54) + t8 * t70) + t8 * t10 * t16 * 2.0) + t6 * t9 * t25)
                   - a_tmp * t32 * 2.0) - a_tmp * t33 * 2.0) + a_tmp * t52 * 2.0)
                - b_a_tmp * t10 * 2.0) + b_a_tmp * t32 * 2.0) + b_a_tmp * t33 *
              2.0) - b_a_tmp * t52 * 2.0;
  b_t138_tmp = t7 - in1[1] * t3;
  b_t130_tmp = (((((in1[1] * t54 + t7 * t15) + t9 * t10 * t19) + t134_tmp * t32)
                 + t138_tmp * t32) + t134_tmp * t70) + t138_tmp * t70;
  a_tmp = in3[1] * t22 * t24;
  b_a_tmp = in3[0] * (in2[0] * in2[0]);
  t127_tmp = b_a_tmp * t16;
  t134_tmp = b_a_tmp * t18;
  M[0] = (((a_tmp * (a * a) / 4.0 + a_tmp * (t130_tmp * t130_tmp) / 4.0) +
           t127_tmp * t22 * t50 / 4.0) + t134_tmp * t22 * t50 / 4.0) + in3[1] *
    (t7 * t7) * t13 * t24 * (t42 * t42) * t51 / 4.0;
  M[1] = -t140;
  M[2] = -t134;
  M[3] = t130;
  M[4] = -t140;
  M[5] = ((((b_a_tmp * t23 * (b_t138_tmp * b_t138_tmp) / 4.0 + in3[1] * t23 *
             t24 * (b_t130_tmp * b_t130_tmp) / 4.0) + t127_tmp * t23 * t95 / 4.0)
           + t134_tmp * t23 * t95 / 4.0) + in3[1] * t16 * t23 * t24 * t132 / 4.0)
    + in3[1] * t18 * t23 * t24 * t132 / 4.0;
  M[6] = -t127;
  M[7] = t11;
  M[8] = -t134;
  M[9] = -t127;
  a_tmp = in3[1] * t13;
  M[10] = a_tmp * t24 * t51 / 4.0;
  M[11] = 0.0;
  M[12] = t130;
  M[13] = t11;
  M[14] = 0.0;
  M[15] = a_tmp * (t24 * t24) * (((t5 - 1.0) * 2.0 + in1[3] * t9 * 2.0) - 1.0 /
    t24) * -0.25;
}

int main(){
  double q[4] = {0.3, 0.3, 0.3, 0.3};
  double L[2] = {0.125, 0.125};
  double m[2] = {0.16, 0.082};
  double inertia[16];
  M_fun(q,L,m,inertia);
  Eigen::MatrixXd inertiaM = Eigen::MatrixXd::Zero(4,4);
  for (int i = 0; i < 4; i++){
    for(int j = 0; j < 4; j++){
      inertiaM(i,j) = inertia[4*i+j];
    }
  }
  std::cout << inertiaM;
  std::cout << inertiaM*Eigen::VectorXd::Ones(4);
}
//
// File trailer for M_fun.cpp
//
// [EOF]
//
